---
title: 'Deployment'
description: 'Learn how to deploy, version, and manage AI Builder applications across environments'
---

<Frame>
  <img src="/images/deployment-hero.png" alt="AI Builder Deployment" />
</Frame>


Successfully deploying AI Builder applications requires a structured approach to ensure reliability, performance, and proper governance. This guide covers deployment strategies, environment management, version control, and best practices for taking your applications from development to production.

## Deployment Strategies

<Tabs>
  <Tab title="Environment-Based">
    <Frame>
      <img src="/images/environment-deployment.png" alt="Environment-Based Deployment" />
    </Frame>
    
    Promote applications through defined environments:
    
    - **Development**: Building and initial testing
    - **Staging/QA**: Verification and validation
    - **Production**: Live user access
    - **Sandbox**: Experimentation and learning
    
    This approach creates clear separation between environments with different stability requirements and access controls.
  </Tab>
  
  <Tab title="Workspace Packaging">
    <Frame>
      <img src="/images/workspace-packaging.png" alt="Workspace Packaging" />
    </Frame>
    
    Package workspaces as deployable units:
    
    - **Create Versions**: Snapshot workspaces at specific points
    - **Package as Apps**: Convert workspaces to installable apps
    - **Push/Pull**: Move workspaces between environments
    - **Import/Export**: Transfer workspace configurations
    
    Workspace packaging enables controlled deployment of complete solutions across environments.
  </Tab>
  
  <Tab title="Git Integration">
    <Frame>
      <img src="/images/git-integration.png" alt="Git Integration" />
    </Frame>
    
    Use Git for version control and deployment:
    
    - **Repository Sync**: Connect workspaces to Git repositories
    - **Branch Strategy**: Use branches for environment isolation
    - **Pull Requests**: Review changes before deployment
    - **CI/CD Integration**: Automate testing and deployment
    
    Git integration brings software development best practices to AI application lifecycle management.
  </Tab>
</Tabs>

## Environment Management

Configure and manage different deployment environments:

<AccordionGroup>
  <Accordion title="Environment Configuration">
    <Frame>
      <img src="/images/environment-configuration.png" alt="Environment Configuration" />
    </Frame>
    
    Define environment-specific settings:
    
    - **Instance Settings**: Configure Prisme.ai instances for different environments
    - **Resource Allocation**: Adjust compute resources for expected load
    - **Network Configuration**: Set up connectivity and access rules
    - **Integration Endpoints**: Configure different external service connections
    - **Monitoring Settings**: Define appropriate observability levels
    
    Proper environment configuration ensures each environment serves its purpose effectively.
    
    <Properties>
      <Property name="Development Environment" value="Optimized for rapid iteration">
        - Lower resources
        - Relaxed security for development access
        - Mock integrations for external systems
        - Detailed logging and diagnostics
        - Individual workspace isolation
      </Property>
      <Property name="Staging/QA Environment" value="Mirrors production for validation">
        - Production-equivalent resources
        - Production-like security controls
        - Test versions of integrations
        - Enhanced monitoring for validation
        - Shared testing workspaces
      </Property>
      <Property name="Production Environment" value="Optimized for reliability and performance">
        - Scaled resources for actual load
        - Strict security controls
        - Real integration endpoints
        - Production monitoring and alerting
        - Controlled access and change management
      </Property>
    </Properties>
  </Accordion>
  
  <Accordion title="Multi-instance Deployment">
    <Frame>
      <img src="/images/multi-instance.png" alt="Multi-instance Deployment" />
    </Frame>
    
    Deploy across multiple Prisme.ai instances:
    
    - **Instance Separation**: Different instances for development, staging, production
    - **Cross-Instance Migration**: Processes for moving applications between instances
    - **Configuration Management**: Handling instance-specific settings
    - **Access Control**: Separate user roles across instances
    - **Network Isolation**: Security boundaries between environments
    
    Multi-instance deployment provides the strongest isolation between environments but requires additional management overhead.
  </Accordion>
  
  <Accordion title="Environment Variables">
    <Frame>
      <img src="/images/environment-variables.png" alt="Environment Variables" />
    </Frame>
    
    Use variables to manage environment-specific values:
    
    - **Configuration Variables**: Different settings per environment
    - **Connection Strings**: Environment-specific endpoints
    - **Secret Management**: Secure credential storage
    - **Feature Flags**: Enable/disable features by environment
    - **Service Levels**: Adjust resource usage parameters
    
    Environment variables allow the same code to operate differently in each environment, simplifying deployment.
    
    Example variable usage:
    
    ```javascript
    // Access environment-specific API endpoint
    const apiEndpoint = process.env.API_ENDPOINT;
    
    // Use environment-specific feature flag
    const isFeatureEnabled = process.env.ENABLE_NEW_FEATURE === 'true';
    
    // Configure resource limits based on environment
    const maxConcurrentRequests = parseInt(process.env.MAX_CONCURRENT_REQUESTS, 10);
    ```
  </Accordion>
  
  <Accordion title="Scaling Configuration">
    <Frame>
      <img src="/images/scaling-configuration.png" alt="Scaling Configuration" />
    </Frame>
    
    Configure resources to handle expected load:
    
    - **Horizontal Scaling**: Add more instances for increased load
    - **Vertical Scaling**: Increase resources per instance
    - **Auto-scaling**: Dynamically adjust based on demand
    - **Rate Limiting**: Control throughput to prevent overload
    - **Resource Allocation**: Optimize for different workloads
    
    Proper scaling ensures reliable performance and efficient resource usage.
  </Accordion>
</AccordionGroup>

## Version Control and Packaging

Manage application versions for controlled deployment:

<Steps>
  <Step title="Git Repository Configuration">
    Connect workspaces to version control:
    
    <Frame>
      <img src="/images/git-setup.png" alt="Git Repository Configuration" />
    </Frame>
    
    Key setup steps:
    1. Configure Git repository connection in workspace settings
    2. Set up authentication (SSH keys or credentials)
    3. Define tracked branches
    4. Configure sync behavior
    5. Set commit message templates
    
    Git integration provides history, backup, and collaboration capabilities.
  </Step>
  
  <Step title="Creating Versions">
    Snapshot applications at specific points:
    
    <Frame>
      <img src="/images/creating-versions.png" alt="Creating Versions" />
    </Frame>
    
    Version creation process:
    1. Ensure all changes are tested and ready
    2. Create a version with semantic versioning (e.g., 1.2.3)
    3. Add version notes describing changes
    4. Tag the version in Git if using repository integration
    5. Lock version to prevent further changes
    
    Versions create stable reference points for deployment.
  </Step>
  
  <Step title="Packaging as Apps">
    Convert workspaces to deployable applications:
    
    <Frame>
      <img src="/images/packaging-apps.png" alt="Packaging as Apps" />
    </Frame>
    
    Packaging process:
    1. Go to workspace settings and select "Packaging"
    2. Configure app metadata (name, description, version)
    3. Select components to include in the package
    4. Specify configuration requirements
    5. Generate the app package
    
    Packaged apps can be easily shared and deployed across environments.
  </Step>
  
  <Step title="Pushing to Different Environments">
    Deploy versions to target environments:
    
    <Frame>
      <img src="/images/pushing-environments.png" alt="Pushing to Environments" />
    </Frame>
    
    Deployment steps:
    1. Select the version to deploy
    2. Choose the target environment
    3. Verify environment-specific configurations
    4. Initiate the push operation
    5. Validate successful deployment
    
    Pushing maintains version integrity while moving applications between environments.
  </Step>
  
  <Step title="Managing Rollbacks">
    Revert to previous versions when needed:
    
    <Frame>
      <img src="/images/managing-rollbacks.png" alt="Managing Rollbacks" />
    </Frame>
    
    Rollback process:
    1. Identify the stable version to roll back to
    2. Initiate rollback operation
    3. Verify configuration compatibility
    4. Apply the previous version
    5. Validate system operation after rollback
    
    Rollback capabilities provide safety when issues are discovered after deployment.
  </Step>
</Steps>

## Deployment Workflow

A typical end-to-end deployment process follows these stages:

<Frame>
  <img src="/images/deployment-workflow.png" alt="Deployment Workflow" />
</Frame>

<Steps>
  <Step title="Development">
    Create and test application components:
    
    - Build blocks, pages, and automations
    - Perform unit testing and local validation
    - Collaborate with team members
    - Create feature branches for parallel work
    - Document components and functionality
    
    Development focuses on creating and initially validating functionality.
  </Step>
  
  <Step title="Integration Testing">
    Validate components working together:
    
    - Merge feature branches to integration branch
    - Test end-to-end flows across components
    - Verify external system integrations
    - Identify and resolve interaction issues
    - Validate performance at system level
    
    Integration testing ensures the complete application functions correctly.
  </Step>
  
  <Step title="Staging Deployment">
    Deploy to pre-production environment:
    
    - Create versioned snapshot
    - Deploy to staging environment
    - Configure for staging systems
    - Perform user acceptance testing
    - Validate performance and security
    
    Staging deployment provides final validation before production.
  </Step>
  
  <Step title="Production Deployment">
    Release to live users:
    
    - Schedule production deployment window
    - Deploy approved version to production
    - Monitor deployment process
    - Verify critical functionality
    - Enable for user access
    
    Production deployment makes the application available to end users.
  </Step>
  
  <Step title="Post-Deployment Monitoring">
    Track application performance and usage:
    
    - Monitor system health and performance
    - Collect user feedback
    - Track usage patterns
    - Identify any issues requiring attention
    - Gather data for future improvements
    
    Monitoring ensures the deployment remains stable and meets user needs.
  </Step>
</Steps>

## CI/CD Integration

Automate deployment processes with continuous integration and deployment:

<Tabs>
  <Tab title="Build Pipelines">
    <Frame>
      <img src="/images/build-pipelines.png" alt="Build Pipelines" />
    </Frame>
    
    Automatically validate code changes:
    
    - **Automated Testing**: Run tests on every commit
    - **Code Quality Checks**: Enforce standards and best practices
    - **Artifact Generation**: Create deployable packages
    - **Build Notifications**: Alert teams to build status
    - **Dependency Scanning**: Check for security issues
    
    Build pipelines ensure code quality before deployment.
  </Tab>
  
  <Tab title="Deployment Pipelines">
    <Frame>
      <img src="/images/deployment-pipelines.png" alt="Deployment Pipelines" />
    </Frame>
    
    Automate the deployment process:
    
    - **Environment Promotion**: Sequential deployment through environments
    - **Approval Gates**: Require human verification for critical stages
    - **Configuration Management**: Apply environment-specific settings
    - **Rollback Automation**: Quick recovery from failed deployments
    - **Deployment Scheduling**: Timed releases during maintenance windows
    
    Deployment pipelines standardize and streamline the release process.
  </Tab>
  
  <Tab title="Infrastructure as Code">
    <Frame>
      <img src="/images/infrastructure-as-code.png" alt="Infrastructure as Code" />
    </Frame>
    
    Manage deployment environments as code:
    
    - **Environment Definitions**: Codify environment configurations
    - **Version Controlled Infrastructure**: Track infrastructure changes
    - **Repeatable Setup**: Consistent environment creation
    - **Automated Provisioning**: Dynamically create environments
    - **Configuration Validation**: Verify environment settings
    
    Infrastructure as Code ensures consistent and repeatable environment setup.
  </Tab>
</Tabs>

## Security in Deployment

Maintain security throughout the deployment process:

<AccordionGroup>
  <Accordion title="Secrets Management">
    <Frame>
      <img src="/images/secrets-management.png" alt="Secrets Management" />
    </Frame>
    
    Securely handle sensitive information:
    
    - **Environment-Specific Secrets**: Different credentials per environment
    - **Secure Storage**: Encrypted secret repositories
    - **Access Control**: Limit who can view or use secrets
    - **Rotation Policies**: Regular credential updates
    - **Secret References**: Use references rather than hard-coded values
    
    <Properties>
      <Property name="Secret Types" value="API keys, passwords, certificates, tokens">
        Sensitive information requiring protection
      </Property>
      <Property name="Storage Options" value="Workspace secrets, external vaults, environment variables">
        Secure locations for credential storage
      </Property>
      <Property name="Access Patterns" value="Runtime only, need-to-know basis">
        How and when secrets are available
      </Property>
    </Properties>
  </Accordion>
  
  <Accordion title="Deployment Permissions">
    <Frame>
      <img src="/images/deployment-permissions.png" alt="Deployment Permissions" />
    </Frame>
    
    Control who can deploy applications:
    
    - **Role-Based Deployment**: Limit deployment capabilities to specific roles
    - **Environment Restrictions**: Different permissions for different environments
    - **Approval Workflows**: Require multi-person approval for production
    - **Audit Logging**: Track all deployment actions
    - **Principle of Least Privilege**: Grant minimal necessary permissions
    
    <Properties>
      <Property name="Developer Role" value="Can deploy to development only">
        Limited to early-stage environments
      </Property>
      <Property name="Release Manager Role" value="Can approve and deploy to production">
        Specialized role for controlled releases
      </Property>
      <Property name="Admin Role" value="Can configure deployment settings">
        Infrastructure and configuration management
      </Property>
    </Properties>
  </Accordion>
  
  <Accordion title="Security Scanning">
    <Frame>
      <img src="/images/security-scanning.png" alt="Security Scanning" />
    </Frame>
    
    Validate application security before deployment:
    
    - **Code Scanning**: Identify vulnerabilities in custom code
    - **Dependency Checks**: Verify third-party components
    - **Configuration Analysis**: Check for security misconfigurations
    - **Compliance Validation**: Verify adherence to policies
    - **Penetration Testing**: Simulate attacks on pre-production environments
    
    <Properties>
      <Property name="Scanning Tools" value="Static analysis, dynamic analysis, composition analysis">
        Different methods for security evaluation
      </Property>
      <Property name="Integration Points" value="Pre-commit, build pipeline, pre-deployment">
        When security checks are performed
      </Property>
      <Property name="Issue Handling" value="Severity classification, remediation guidance">
        How security findings are addressed
      </Property>
    </Properties>
  </Accordion>
</AccordionGroup>

## Deployment Monitoring

Track deployment health and performance:

<CardGroup cols={2}>
  <Card title="Deployment Metrics" icon="chart-line">
    <p>Measure deployment effectiveness:</p>
    <ul>
      <li>Deployment frequency</li>
      <li>Deployment duration</li>
      <li>Change failure rate</li>
      <li>Mean time to recover</li>
      <li>Rollback frequency</li>
    </ul>
  </Card>
  
  <Card title="Application Health" icon="heart-pulse">
    <p>Monitor application well-being:</p>
    <ul>
      <li>Error rates and exceptions</li>
      <li>Response times</li>
      <li>Resource utilization</li>
      <li>User activity patterns</li>
      <li>System availability</li>
    </ul>
  </Card>
  
  <Card title="User Impact" icon="users">
    <p>Track effect on end users:</p>
    <ul>
      <li>User-reported issues</li>
      <li>Adoption metrics</li>
      <li>Feature utilization</li>
      <li>Satisfaction scores</li>
      <li>Support ticket volume</li>
    </ul>
  </Card>
  
  <Card title="Performance Monitoring" icon="gauge-high">
    <p>Ensure optimal performance:</p>
    <ul>
      <li>Transaction times</li>
      <li>Load testing results</li>
      <li>Scalability metrics</li>
      <li>Bottleneck identification</li>
      <li>Comparative benchmarks</li>
    </ul>
  </Card>
</CardGroup>

## Multi-Region Deployment

Deploy applications across geographic regions:

<Frame>
  <img src="/images/multi-region-deployment.png" alt="Multi-Region Deployment" />
</Frame>

<AccordionGroup>
  <Accordion title="Region Strategy">
    Determine your multi-region approach:
    
    - **Active-Active**: Multiple active regions serving users
    - **Active-Passive**: Primary region with standby backups
    - **Regional Isolation**: Independent regions for different user groups
    - **Data Sovereignty**: Region-specific data storage and processing
    - **Geographic Proximity**: Minimize latency for user groups
    
    The right strategy depends on performance, compliance, and reliability requirements.
  </Accordion>
  
  <Accordion title="Data Synchronization">
    Manage data across regions:
    
    - **Replication Patterns**: How and when data is copied
    - **Consistency Models**: Balance between consistency and availability
    - **Conflict Resolution**: Handle simultaneous updates
    - **Migration Strategies**: Move users between regions
    - **Data Residency Controls**: Enforce data location policies
    
    Data synchronization is critical for multi-region operation.
  </Accordion>
  
  <Accordion title="Traffic Management">
    Direct users to appropriate regions:
    
    - **Geo-Routing**: Send users to nearest region
    - **Load Balancing**: Distribute traffic across regions
    - **Failover Configuration**: Redirect during outages
    - **Health Checking**: Monitor region availability
    - **Gradual Rollout**: Deploy to regions incrementally
    
    Traffic management ensures optimal user experience and system resilience.
  </Accordion>
</AccordionGroup>

## Deployment Best Practices

<CardGroup cols={2}>
  <Card title="Automate Everything" icon="robot">
    <p>Minimize manual steps:</p>
    <ul>
      <li>Automate testing and validation</li>
      <li>Create deployment scripts</li>
      <li>Use infrastructure as code</li>
      <li>Implement CI/CD pipelines</li>
      <li>Automate post-deployment checks</li>
    </ul>
  </Card>
  
  <Card title="Version Control" icon="code-branch">
    <p>Maintain complete history:</p>
    <ul>
      <li>Version all application components</li>
      <li>Use semantic versioning</li>
      <li>Document version changes</li>
      <li>Tag important releases</li>
      <li>Maintain deployment history</li>
    </ul>
  </Card>
  
  <Card title="Blue-Green Deployment" icon="shuffle">
    <p>Minimize deployment risk:</p>
    <ul>
      <li>Maintain parallel environments</li>
      <li>Deploy to inactive environment</li>
      <li>Test thoroughly before switching</li>
      <li>Switch traffic when validated</li>
      <li>Keep previous environment for rollback</li>
    </ul>
  </Card>
  
  <Card title="Canary Releases" icon="bird">
    <p>Gradually expose new versions:</p>
    <ul>
      <li>Deploy to subset of users first</li>
      <li>Monitor for issues with small impact</li>
      <li>Gradually increase rollout</li>
      <li>Revert quickly if problems appear</li>
      <li>Collect feedback during rollout</li>
    </ul>
  </Card>
  
  <Card title="Immutable Infrastructure" icon="lock">
    <p>Don't modify, replace:</p>
    <ul>
      <li>Create new environments rather than updating</li>
      <li>Deploy complete versions, not patches</li>
      <li>Avoid configuration drift</li>
      <li>Maintain consistency across environments</li>
      <li>Simplify rollback by reverting to previous state</li>
    </ul>
  </Card>
  
  <Card title="Comprehensive Monitoring" icon="eye">
    <p>Watch everything:</p>
    <ul>
      <li>Monitor the deployment process itself</li>
      <li>Track application health metrics</li>
      <li>Watch user-facing performance</li>
      <li>Set up alerts for critical issues</li>
      <li>Compare metrics before and after deployment</li>
    </ul>
  </Card>
</CardGroup>

## Deployment Challenges and Solutions

<AccordionGroup>
  <Accordion title="Dependency Management">
    <Frame>
      <img src="/images/dependency-management.png" alt="Dependency Management" />
    </Frame>
    
    **Challenge**: Managing external dependencies across environments.
    
    **Solutions**:
    - Lock dependency versions for consistency
    - Test with actual integration points before deployment
    - Use dependency proxies for stability
    - Implement fallbacks for critical dependencies
    - Document all external dependencies and their versions
  </Accordion>
  
  <Accordion title="Database Migrations">
    <Frame>
      <img src="/images/database-migrations.png" alt="Database Migrations" />
    </Frame>
    
    **Challenge**: Evolving database schemas without disruption.
    
    **Solutions**:
    - Use versioned migration scripts
    - Implement backward compatible changes
    - Deploy database changes before code that depends on them
    - Have rollback scripts prepared
    - Test migrations in non-production environments
  </Accordion>
  
  <Accordion title="Configuration Drift">
    <Frame>
      <img src="/images/configuration-drift.png" alt="Configuration Drift" />
    </Frame>
    
    **Challenge**: Environments becoming inconsistent over time.
    
    **Solutions**:
    - Define infrastructure and configuration as code
    - Automate environment creation and updates
    - Perform regular configuration audits
    - Rebuild environments instead of modifying them
    - Document all environment differences by design
  </Accordion>
  
  <Accordion title="Deployment Coordination">
    <Frame>
      <img src="/images/deployment-coordination.png" alt="Deployment Coordination" />
    </Frame>
    
    **Challenge**: Coordinating deployments across teams and components.
    
    **Solutions**:
    - Establish release calendars and windows
    - Use feature flags to decouple deployment from release
    - Implement clear communication channels for deployments
    - Designate release coordinators for complex deployments
    - Create deployment runbooks for consistent processes
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="RBAC"
    icon="user-lock"
    href="/products/ai-builder/rbac"
  >
    Learn about role-based access control for deployments
  </Card>
  <Card
    title="Advanced Topics"
    icon="graduation-cap"
    href="/products/ai-builder/advanced-topics"
  >
    Explore advanced deployment techniques
  </Card>
  <Card
    title="Testing & Debugging"
    icon="vial"
    href="/products/ai-builder/testing-debugging"
  >
    Understand pre-deployment validation
  </Card>
  <Card
    title="Use Cases"
    icon="lightbulb"
    href="/products/ai-builder/use-cases"
  >
    See deployment in real-world scenarios
  </Card>
</CardGroup>