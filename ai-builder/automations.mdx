---
title: 'Automations'
description: 'Create powerful backend processes and workflows to orchestrate your AI applications'
---

<Frame>
  <img src="/images/automations-hero.png" alt="AI Builder Automations Interface" />
</Frame>

Automations in AI Builder represent the server-side logic that powers your applications. They process data, orchestrate workflows, connect to external systems, and respond to eventsâ€”creating the intelligence behind your user interfaces.

## Understanding Automations

<Tabs>
  <Tab title="What are Automations?">
    <Frame>
      <img src="/images/automation-concepts.png" alt="Automation Concepts" />
    </Frame>
    
    Automations are server-side processes that:
    
    - **Execute Logic**: Perform calculations, transformations, and decisions
    - **Process Events**: Respond to triggers from UI or external systems
    - **Integrate Systems**: Connect with APIs, databases, and services
    - **Orchestrate Workflows**: Coordinate multi-step processes
    - **Emit Events**: Trigger UI updates and other automations
    
    They represent the application tier in the three-tier architecture.
  </Tab>
  
  <Tab title="Automation Types">
    <Frame>
      <img src="/images/automation-types.png" alt="Automation Types" />
    </Frame>
    
    AI Builder supports several types of automations:
    
    - **Event-Triggered**: Activated by system or custom events
    - **API/Webhook**: Exposed as HTTP endpoints
    - **Scheduled**: Run on predefined schedules (cron)
    - **Sequential**: Execute steps in order
    - **Parallel**: Process multiple operations simultaneously
    
    Each type serves different purposes in your application.
  </Tab>
  
  <Tab title="Automation Architecture">
    <Frame>
      <img src="/images/automation-architecture.png" alt="Automation Architecture" />
    </Frame>
    
    Automations are built on a modern serverless architecture:
    
    - **Node.js Runtime**: JavaScript/TypeScript execution environment
    - **Event Processing**: Async handling of events and messages
    - **State Management**: Variable scopes for data persistence
    - **Error Handling**: Robust exception management
    - **Logging & Monitoring**: Comprehensive observability
    
    This architecture ensures scalable, maintainable backend processes.
  </Tab>
</Tabs>

## Working with Automations

<Steps>
  <Step title="Creating Automations">
    Start a new automation through the AI Builder interface:
    
    <Frame>
      <img src="/images/creating-automations.png" alt="Creating Automations" />
    </Frame>
    
    To create an automation:
    1. Navigate to the "Automations" folder in your workspace
    2. Click the "+" button to add a new automation
    3. Choose an automation type (event, API, scheduled)
    4. Enter a unique slug for the automation
    5. Provide a name and description
    
    The automation slug identifies it within your workspace and for API endpoints.
  </Step>
  
  <Step title="Configuring Triggers">
    Define what activates the automation:
    
    <Frame>
      <img src="/images/automation-triggers.png" alt="Automation Triggers" />
    </Frame>
    
    Trigger types include:
    - **Event**: Listens for specific events from UI or other automations
    - **API/Webhook**: Creates an HTTP endpoint at `/api/[workspace-slug]/[automation-slug]`
    - **Schedule**: Runs on a time-based pattern using cron syntax
    - **Manual**: Executed on-demand from the interface
    
    Proper trigger configuration ensures the automation runs at the right time.
  </Step>
  
  <Step title="Building Logic Flow">
    Construct the automation's logic using instructions:
    
    <Frame>
      <img src="/images/automation-logic-flow.png" alt="Automation Logic Flow" />
    </Frame>
    
    The process involves:
    1. Adding instructions from the sidebar
    2. Configuring each instruction's properties
    3. Arranging instructions in the desired sequence
    4. Creating logic branches with conditions
    5. Managing data flow between steps
    
    Instructions can be sequenced, nested, and branched to create complex workflows.
  </Step>
  
  <Step title="Working with Variables">
    Manage data throughout the automation:
    
    <Frame>
      <img src="/images/automation-variables.png" alt="Automation Variables" />
    </Frame>
    
    Variable operations include:
    - **Set Variables**: Create or update values
    - **Read Variables**: Access stored information
    - **Delete Variables**: Remove data when no longer needed
    - **Transform Variables**: Modify data structure or format
    
    Variables use the `{{scope.name}}` syntax and can exist in different scopes.
  </Step>
  
  <Step title="Error Handling">
    Implement robust error management:
    
    <Frame>
      <img src="/images/automation-error-handling.png" alt="Automation Error Handling" />
    </Frame>
    
    Error handling approaches:
    - **Try/Catch Blocks**: Contain and manage exceptions
    - **Error Logging**: Record issues for troubleshooting
    - **Fallback Logic**: Alternative paths when errors occur
    - **Graceful Degradation**: Partial functionality despite failures
    
    Proper error handling ensures reliability and maintainability.
  </Step>
  
  <Step title="Testing Automations">
    Validate your automation's functionality:
    
    <Frame>
      <img src="/images/testing-automations.png" alt="Testing Automations" />
    </Frame>
    
    Testing options include:
    - **Manual Execution**: Run with test inputs
    - **Event Simulation**: Trigger with test events
    - **API Testing**: Send requests to HTTP endpoints
    - **Log Analysis**: Review execution records
    - **Debugger**: Step through execution
    
    Thorough testing ensures automations work as expected.
  </Step>
</Steps>

## Built-in Instructions

AI Builder provides a comprehensive library of built-in instructions for creating automation logic:

<AccordionGroup>
  <Accordion title="Flow Control">
    <CardGroup cols={3}>
      <Card title="Condition" icon="code-branch">
        Create branching logic based on conditions
      </Card>
      <Card title="Switch" icon="shuffle">
        Multi-path branching based on a value
      </Card>
      <Card title="Repeat" icon="arrows-rotate">
        Loop through a collection or a fixed number of times
      </Card>
      <Card title="All" icon="layer-group">
        Execute multiple operations in parallel
      </Card>
      <Card title="Break" icon="stop">
        Exit from loops or automations
      </Card>
      <Card title="Comment" icon="comment">
        Add documentation within the flow
      </Card>
    </CardGroup>
  </Accordion>
  
  <Accordion title="Data Operations">
    <CardGroup cols={3}>
      <Card title="Set Variable" icon="pen">
        Create or update variables in different scopes
      </Card>
      <Card title="Delete Variable" icon="trash">
        Remove variables when no longer needed
      </Card>
      <Card title="Transform" icon="wand-magic-sparkles">
        Modify data structure or format
      </Card>
      <Card title="Math" icon="calculator">
        Perform mathematical calculations
      </Card>
      <Card title="Array Operations" icon="list">
        Manipulate arrays (map, filter, reduce, etc.)
      </Card>
      <Card title="Object Operations" icon="cube">
        Work with object properties and structures
      </Card>
    </CardGroup>
  </Accordion>
  
  <Accordion title="Integration">
    <CardGroup cols={3}>
      <Card title="HTTP Request" icon="globe">
        Make calls to external APIs and services
      </Card>
      <Card title="Emit Event" icon="bolt">
        Trigger events for UI updates or other automations
      </Card>
      <Card title="Webhook" icon="link">
        Configure outbound webhook calls
      </Card>
      <Card title="Database Operations" icon="database">
        Connect to and query databases
      </Card>
      <Card title="File Operations" icon="file">
        Create, read, and manipulate files
      </Card>
      <Card title="Email" icon="envelope">
        Send and process emails
      </Card>
    </CardGroup>
  </Accordion>
  
  <Accordion title="AI Operations">
    <CardGroup cols={3}>
      <Card title="LLM Query" icon="robot">
        Send requests to language models
      </Card>
      <Card title="Knowledge Base" icon="book">
        Query and update RAG knowledge bases
      </Card>
      <Card title="Vector Operations" icon="network-wired">
        Work with embeddings and vector data
      </Card>
      <Card title="Agent Orchestration" icon="sitemap">
        Coordinate multiple AI agents
      </Card>
      <Card title="Prompt Templates" icon="message">
        Manage and apply prompt templates
      </Card>
      <Card title="Document Processing" icon="file-lines">
        Extract and analyze document content
      </Card>
    </CardGroup>
  </Accordion>
  
  <Accordion title="Utility">
    <CardGroup cols={3}>
      <Card title="Log" icon="terminal">
        Record information for debugging
      </Card>
      <Card title="Sleep" icon="clock">
        Pause execution for a specified duration
      </Card>
      <Card title="Date/Time" icon="calendar">
        Work with dates, times, and durations
      </Card>
      <Card title="Format" icon="font">
        Format strings, numbers, and other values
      </Card>
      <Card title="Validation" icon="check-double">
        Verify data against rules and schemas
      </Card>
      <Card title="Error" icon="triangle-exclamation">
        Throw and handle custom errors
      </Card>
    </CardGroup>
  </Accordion>
</AccordionGroup>

## Memory Architecture

Automations can use and modify data across different memory scopes:

<Frame>
  <img src="/images/automation-memory-scopes.png" alt="Automation Memory Scopes" />
</Frame>

<Properties>
  <Property name="Run Scope" value="Available only during current execution">
    Access pattern: `{{run.variable}}`
    
    Run variables include execution context like:
    - `run.date`: Current timestamp
    - `run.ip`: Client IP address
    - `run.slug`: Automation identifier
    - `run.environment`: Current environment (e.g., production, staging)
    - Custom variables specific to the current execution
  </Property>
  
  <Property name="User Scope" value="Persistent for the authenticated user">
    Access pattern: `{{user.variable}}`
    
    User variables include:
    - `user.id`: Unique user identifier
    - `user.email`: User's email address 
    - `user.authData`: Authentication information
    - Custom user-specific data that persists across sessions
  </Property>
  
  <Property name="Session Scope" value="Available for the current user session">
    Access pattern: `{{session.variable}}`
    
    Session variables store temporary user data:
    - Form inputs across multiple steps
    - Wizard progress state
    - Temporary preferences
    - Workflow state that shouldn't persist permanently
  </Property>
  
  <Property name="Global Scope" value="Shared across all users and executions">
    Access pattern: `{{global.variable}}`
    
    Global variables store workspace-wide information:
    - Configuration settings
    - Shared reference data
    - Cross-user counters and metrics
    - System-wide state information
  </Property>
</Properties>

## API & Webhook Integration

Automations can expose and consume APIs for system integration:

<Tabs>
  <Tab title="Inbound APIs">
    <Frame>
      <img src="/images/inbound-apis.png" alt="Inbound APIs" />
    </Frame>
    
    Expose automations as HTTP endpoints:
    
    - **URL Pattern**: `/api/[workspace-slug]/[automation-slug]`
    - **HTTP Methods**: GET, POST, PUT, DELETE
    - **Authentication**: API keys, JWT, custom auth
    - **Request Parsing**: Access headers, query params, body
    - **Response Control**: Status codes, headers, body formats
    
    Example automation for an inbound API:
    
    ```
    [Trigger: API]
    â†“
    [Log: Request received]
    â†“
    [Condition: Valid request?]
    â”œâ”€ [Yes] â†’ [Process data]
    â”‚           â†“
    â”‚           [Return success response]
    â”‚
    â””â”€ [No] â†’ [Return error response]
    ```
  </Tab>
  
  <Tab title="Outbound Requests">
    <Frame>
      <img src="/images/outbound-requests.png" alt="Outbound Requests" />
    </Frame>
    
    Call external APIs from automations:
    
    - **HTTP Methods**: Full support for REST and GraphQL
    - **Authentication**: Various auth methods (Basic, Bearer, OAuth)
    - **Request Configuration**: Headers, query params, body
    - **Response Handling**: JSON parsing, error handling
    - **Streaming**: Support for large data transfers
    
    Example automation for an outbound API call:
    
    ```
    [Trigger: Event]
    â†“
    [Set Variable: Prepare request data]
    â†“
    [HTTP Request: Call external API]
    â†“
    [Condition: Successful response?]
    â”œâ”€ [Yes] â†’ [Process response data]
    â”‚           â†“
    â”‚           [Emit Event: Data processed]
    â”‚
    â””â”€ [No] â†’ [Log: Error details]
               â†“
               [Emit Event: Error occurred]
    ```
  </Tab>
  
  <Tab title="Webhooks">
    <Frame>
      <img src="/images/webhooks.png" alt="Webhooks" />
    </Frame>
    
    Configure event-based callbacks:
    
    - **Inbound Webhooks**: Receive events from external systems
    - **Outbound Webhooks**: Send events to external listeners
    - **Authentication**: HMAC verification, API keys
    - **Payload Templates**: Customize event data format
    - **Retry Logic**: Handle delivery failures
    
    Example automation for webhook handling:
    
    ```
    [Trigger: API (Webhook)]
    â†“
    [Condition: Valid webhook signature?]
    â”œâ”€ [Yes] â†’ [Log: Valid webhook received]
    â”‚           â†“
    â”‚           [Parse webhook payload]
    â”‚           â†“
    â”‚           [Emit Event: Webhook processed]
    â”‚
    â””â”€ [No] â†’ [Log: Invalid webhook attempt]
               â†“
               [Return 403 Forbidden]
    ```
  </Tab>
</Tabs>

## Event-Driven Communication

Automations communicate through events in an event-driven architecture:

<Steps>
  <Step title="Event Listening">
    Configure automations to listen for specific events:
    
    <Frame>
      <img src="/images/event-listening.png" alt="Event Listening" />
    </Frame>
    
    Event trigger configuration includes:
    - **Event Name**: Which event to listen for
    - **Source Filter**: Optional filter by event source
    - **Topic Filter**: Optional subscription to specific topics
    - **Condition**: Additional filtering based on payload data
  </Step>
  
  <Step title="Event Processing">
    Handle the incoming event data:
    
    <Frame>
      <img src="/images/event-processing.png" alt="Event Processing" />
    </Frame>
    
    Processing activities include:
    - Extracting data from the event payload
    - Validating event data
    - Transforming data for processing
    - Executing business logic
    - Storing results in appropriate memory scopes
  </Step>
  
  <Step title="Event Emission">
    Generate new events to trigger further actions:
    
    <Frame>
      <img src="/images/event-emission.png" alt="Event Emission" />
    </Frame>
    
    Event emission configuration includes:
    - **Event Name**: Identifier for the event
    - **Payload**: Data to include with the event
    - **Target**: Where to send the event (UI, other automations)
    - **Topic**: Optional categorization for routing
  </Step>
  
  <Step title="Event Observation">
    Monitor event flow for debugging and analysis:
    
    <Frame>
      <img src="/images/event-observation.png" alt="Event Observation" />
    </Frame>
    
    Observation capabilities include:
    - Real-time event monitoring in Activity
    - Filtering events by type, source, and timestamp
    - Inspecting event payloads
    - Tracking event propagation through the system
  </Step>
</Steps>

## Advanced Automation Features

<AccordionGroup>
  <Accordion title="Parallelization">
    <Frame>
      <img src="/images/automation-parallelization.png" alt="Automation Parallelization" />
    </Frame>
    
    Execute operations concurrently for improved performance:
    
    - **Parallel Processing**: Run multiple operations simultaneously
    - **Task Distribution**: Split work across execution units
    - **Aggregation**: Combine results from parallel operations
    - **Race Conditions**: First-to-complete scenarios
    
    Parallelization significantly improves performance for independent operations.
  </Accordion>
  
  <Accordion title="Error Recovery">
    <Frame>
      <img src="/images/error-recovery.png" alt="Error Recovery" />
    </Frame>
    
    Implement robust recovery mechanisms:
    
    - **Retry Logic**: Attempt failed operations again
    - **Circuit Breakers**: Prevent cascading failures
    - **Fallback Strategies**: Alternative approaches when primary fails
    - **Compensation**: Undo previous steps when later steps fail
    
    Proper error recovery improves reliability and user experience.
  </Accordion>
  
  <Accordion title="Custom Code">
    <Frame>
      <img src="/images/custom-code.png" alt="Custom Code" />
    </Frame>
    
    Extend automations with custom JavaScript/TypeScript:
    
    - **Code Instructions**: Embed code directly in automations
    - **Custom Functions**: Reusable logic components
    - **External Modules**: Import npm packages
    - **Advanced Processing**: Complex algorithms and transformations
    
    Custom code enables handling specialized requirements not covered by built-in instructions.
  </Accordion>
  
  <Accordion title="Batch Processing">
    <Frame>
      <img src="/images/batch-processing.png" alt="Batch Processing" />
    </Frame>
    
    Efficiently process large data volumes:
    
    - **Chunking**: Process data in manageable batches
    - **Pagination**: Handle data that exceeds memory limits
    - **Checkpointing**: Save progress for resumability
    - **Throttling**: Control processing rate
    
    Batch processing enables working with enterprise-scale data volumes.
  </Accordion>
</AccordionGroup>

## Automation Patterns

Common patterns for solving specific challenges with automations:

<Tabs>
  <Tab title="ETL Process">
    <Frame>
      <img src="/images/etl-pattern.png" alt="ETL Pattern" />
    </Frame>
    
    Extract, Transform, Load data processing workflow:
    
    **Implementation:**
    ```
    [Trigger: Schedule or API]
    â†“
    [HTTP Request: Extract data from source]
    â†“
    [Transform: Clean and structure data]
    â†“
    [Database Operations: Load to destination]
    â†“
    [Emit Event: ETL process complete]
    ```
    
    **Common Uses:**
    - Data warehouse loading
    - Report generation
    - Data synchronization
    - Knowledge base updates
  </Tab>
  
  <Tab title="Approval Workflow">
    <Frame>
      <img src="/images/approval-workflow.png" alt="Approval Workflow Pattern" />
    </Frame>
    
    Multi-step approval process with human interaction:
    
    **Implementation:**
    ```
    [Trigger: Form submission event]
    â†“
    [Set Variable: Store submission data]
    â†“
    [Email: Notify approver]
    â†“
    [Trigger: Approval response API]
    â†“
    [Condition: Approved?]
    â”œâ”€ [Yes] â†’ [Process approval]
    â”‚           â†“
    â”‚           [Notify requestor of approval]
    â”‚
    â””â”€ [No] â†’ [Process rejection]
               â†“
               [Notify requestor of rejection]
    ```
    
    **Common Uses:**
    - Document approval
    - Expense processing
    - Content publishing
    - Access requests
  </Tab>
  
  <Tab title="Chatbot Orchestration">
    <Frame>
      <img src="/images/chatbot-orchestration.png" alt="Chatbot Orchestration Pattern" />
    </Frame>
    
    Intelligent conversation flow management:
    
    **Implementation:**
    ```
    [Trigger: Chat message event]
    â†“
    [LLM Query: Analyze intent]
    â†“
    [Switch: Based on intent]
    â”œâ”€ [Information] â†’ [Knowledge Base: Retrieve information]
    â”‚                   â†“
    â”‚                   [LLM Query: Format response]
    â”‚
    â”œâ”€ [Transaction] â†’ [Process transaction]
    â”‚                   â†“
    â”‚                   [Return confirmation]
    â”‚
    â””â”€ [Other] â†’ [LLM Query: General response]
    â†“
    [Emit Event: Response ready]
    ```
    
    **Common Uses:**
    - Customer support
    - Information retrieval
    - Guided workflows
    - Multi-agent coordination
  </Tab>
  
  <Tab title="Scheduled Report">
    <Frame>
      <img src="/images/scheduled-report.png" alt="Scheduled Report Pattern" />
    </Frame>
    
    Automated periodic report generation:
    
    **Implementation:**
    ```
    [Trigger: Schedule (cron)]
    â†“
    [Database Operations: Query data]
    â†“
    [Transform: Format for report]
    â†“
    [Condition: Data available?]
    â”œâ”€ [Yes] â†’ [Generate visualizations]
    â”‚           â†“
    â”‚           [Create report document]
    â”‚           â†“
    â”‚           [Email: Distribute report]
    â”‚
    â””â”€ [No] â†’ [Log: No data available]
               â†“
               [Email: Send notification]
    ```
    
    **Common Uses:**
    - Business intelligence
    - Performance monitoring
    - Compliance reporting
    - Usage analytics
  </Tab>
</Tabs>

## Integration with Prisme.ai Products

Automations connect with other Prisme.ai products for enhanced capabilities:

<CardGroup cols={2}>
  <Card title="AI Knowledge Integration" icon="book">
    <p>Create advanced RAG workflows:</p>
    <ul>
      <li>Query knowledge bases</li>
      <li>Process and index documents</li>
      <li>Implement custom retrieval strategies</li>
      <li>Create webhooks for advanced RAG processing</li>
    </ul>
  </Card>
  
  <Card title="AI SecureChat Orchestration" icon="comments">
    <p>Enhance chat experiences:</p>
    <ul>
      <li>Implement multi-agent conversations</li>
      <li>Create guided conversation flows</li>
      <li>Process and analyze chat history</li>
      <li>Connect chats to business processes</li>
    </ul>
  </Card>
  
  <Card title="AI Collection Data Processing" icon="database">
    <p>Work with structured data:</p>
    <ul>
      <li>Query databases and data sources</li>
      <li>Transform and analyze structured data</li>
      <li>Create data pipelines</li>
      <li>Generate analytics and insights</li>
    </ul>
  </Card>
  
  <Card title="AI Store Component Creation" icon="store">
    <p>Build reusable agent components:</p>
    <ul>
      <li>Package automations as reusable apps</li>
      <li>Create specialized agent capabilities</li>
      <li>Build integration adapters</li>
      <li>Implement common workflow patterns</li>
    </ul>
  </Card>
</CardGroup>

## Best Practices

<CardGroup cols={2}>
  <Card title="Modular Design" icon="cubes">
    <p>Create maintainable automation structures:</p>
    <ul>
      <li>Break complex flows into smaller automations</li>
      <li>Use events for communication between modules</li>
      <li>Create reusable patterns for common tasks</li>
      <li>Document automation purposes and interfaces</li>
    </ul>
  </Card>
  
  <Card title="Error Handling" icon="shield">
    <p>Build robust fault tolerance:</p>
    <ul>
      <li>Anticipate and handle potential failures</li>
      <li>Implement appropriate retry strategies</li>
      <li>Provide informative error messages</li>
      <li>Create fallback paths for critical operations</li>
    </ul>
  </Card>
  
  <Card title="Performance Optimization" icon="gauge-high">
    <p>Ensure efficient execution:</p>
    <ul>
      <li>Use parallelization for independent operations</li>
      <li>Implement caching where appropriate</li>
      <li>Process large datasets in batches</li>
      <li>Minimize unnecessary operations</li>
    </ul>
  </Card>
  
  <Card title="Security Considerations" icon="lock">
    <p>Protect sensitive operations and data:</p>
    <ul>
      <li>Use secrets for sensitive credentials</li>
      <li>Implement proper authentication and authorization</li>
      <li>Validate and sanitize inputs</li>
      <li>Follow the principle of least privilege</li>
    </ul>
  </Card>
  
  <Card title="Observability" icon="eye">
    <p>Enable monitoring and troubleshooting:</p>
    <ul>
      <li>Add strategic logging throughout flows</li>
      <li>Track key metrics and performance indicators</li>
      <li>Implement alerting for critical issues</li>
      <li>Create audit trails for important operations</li>
    </ul>
  </Card>
  
  <Card title="Testing Strategy" icon="vial">
    <p>Validate automation functionality:</p>
    <ul>
      <li>Test with representative data samples</li>
      <li>Verify error handling paths</li>
      <li>Create automated regression tests</li>
      <li>Simulate real-world conditions</li>
    </ul>
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Blocks"
    icon="puzzle-piece"
    href="/products/ai-builder/blocks"
  >
    Learn about UI components that trigger automations
  </Card>
  <Card
    title="Pages"
    icon="file-code"
    href="/products/ai-builder/pages"
  >
    Discover how to create interfaces that connect to automations
  </Card>
  <Card
    title="Integrations"
    icon="plug"
    href="/products/ai-builder/integrations"
  >
    Explore connecting to external systems and services
  </Card>
  <Card
    title="Testing & Debugging"
    icon="vial"
    href="/products/ai-builder/testing-debugging"
  >
    Learn how to validate and troubleshoot automations
  </Card>
</CardGroup>