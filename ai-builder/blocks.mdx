---
title: 'Blocks'
description: 'Build reusable UI components that communicate through events in the AI Builder framework'
---

<Frame>
  <img src="/images/blocks-hero.png" alt="AI Builder Blocks Interface" />
</Frame>


Blocks are reusable UI components that serve as the building blocks for creating interactive interfaces in AI Builder. They encapsulate functionality, emit and listen for events, and can be assembled to create complete user experiences.

## Block Fundamentals

<Tabs>
  <Tab title="What are Blocks?">
    <Frame>
      <img src="/images/block-concepts.png" alt="Block Concepts" />
    </Frame>
    
    Blocks are modular UI components with specific purposes:
    
    - **Self-contained**: Each block encapsulates specific functionality
    - **Reusable**: Can be used across multiple pages and workspaces
    - **Configurable**: Customizable through properties and settings
    - **Interactive**: Respond to user actions and system events
    - **Event-driven**: Communicate with other components through events
    
    Blocks follow the [BlockProtocol.org](https://blockprotocol.org) standard, ensuring consistency and interoperability.
  </Tab>
  
  <Tab title="Block Types">
    <Frame>
      <img src="/images/block-types.png" alt="Block Types" />
    </Frame>
    
    AI Builder provides several categories of blocks:
    
    - **Built-in Blocks**: Core components provided by the platform
    - **Marketplace Blocks**: Components from installed Apps
    - **Custom Blocks**: Your own blocks created from the design system
    - **Template Blocks**: Pre-configured blocks for specific use cases
    
    Each type serves different purposes in your application.
  </Tab>
  
  <Tab title="Block Communication">
    <Frame>
      <img src="/images/block-communication.png" alt="Block Communication" />
    </Frame>
    
    Blocks communicate through an event-driven model:
    
    - **Event Emission**: Blocks emit events when something happens
    - **Event Listening**: Blocks listen for events from other components
    - **Data Exchange**: Events carry payloads with information
    - **Asynchronous Communication**: Non-blocking interaction pattern
    
    This communication model enables loose coupling between components.
  </Tab>
</Tabs>

## Working with Blocks

<Steps>
  <Step title="Adding Blocks">
    Blocks can be added to your workspace in several ways:
    
    <Frame>
      <img src="/images/adding-blocks.png" alt="Adding Blocks" />
    </Frame>
    
    Methods to add blocks:
    - Click "+" under the Blocks folder to browse built-in blocks
    - Install Apps from the marketplace to add their blocks
    - Upload custom blocks developed with your design system
    - Import blocks from other workspaces
  </Step>
  
  <Step title="Configuring Blocks">
    Each block has configurable properties to customize its behavior:
    
    <Frame>
      <img src="/images/configuring-blocks.png" alt="Configuring Blocks" />
    </Frame>
    
    Configuration options:
    - **Slug**: Unique identifier for the block (must be unique in workspace)
    - **Name**: Human-readable title for the block
    - **Description**: Documentation of the block's purpose
    - **Icon**: Visual representation in the interface
    - **Block-specific properties**: Settings unique to each block type
  </Step>
  
  <Step title="Customizing Appearance">
    Modify the visual presentation of blocks:
    
    <Frame>
      <img src="/images/customizing-block-appearance.png" alt="Customizing Block Appearance" />
    </Frame>
    
    Customization options:
    - **CSS Editor**: Write custom CSS for fine-grained control
    - **Theme Properties**: Adjust colors, spacing, and typography
    - **Responsive Settings**: Control appearance across device sizes
    - **State Styling**: Define styles for different interaction states
  </Step>
  
  <Step title="Configuring Events">
    Set up event emission and listening for blocks:
    
    <Frame>
      <img src="/images/configuring-block-events.png" alt="Configuring Block Events" />
    </Frame>
    
    Event configuration involves:
    - Defining which events the block emits
    - Specifying the payload structure for each event
    - Configuring which events the block listens for
    - Determining how the block responds to received events
  </Step>
  
  <Step title="Using Blocks in Pages">
    Once configured, blocks can be added to pages:
    
    <Frame>
      <img src="/images/using-blocks-in-pages.png" alt="Using Blocks in Pages" />
    </Frame>
    
    The process includes:
    - Dragging blocks from the sidebar to the page canvas
    - Arranging blocks in the desired layout
    - Connecting blocks through event bindings
    - Configuring instance-specific properties
  </Step>
</Steps>

## Built-in Block Library

AI Builder includes a comprehensive library of built-in blocks for common UI patterns:

<AccordionGroup>
  <Accordion title="Form Block">
    <CardGroup cols={3}>
      <Card title="Text Input" icon="keyboard">
        Single and multi-line text entry fields
      </Card>
      <Card title="Number Input" icon="hashtag">
        Numeric entry with validation and formatting
      </Card>
      <Card title="Select" icon="list">
        Dropdown selection from predefined options
      </Card>
      <Card title="Checkbox" icon="square-check">
        Boolean selection controls
      </Card>
      <Card title="Radio" icon="circle-dot">
        Single selection from multiple options
      </Card>
      <Card title="File Upload" icon="file-arrow-up">
        Document and media upload capabilities
      </Card>
      <Card title="Form" icon="clipboard">
        Container for organizing form elements
      </Card>
    </CardGroup>
  </Accordion>
  
  <Accordion title="Builtin Blocks">
    <CardGroup cols={3}>
      <Card title="RichText" icon="font">
        Formatted text display with Markdown support
      </Card>
      <Card title="DataTable" icon="table">
        Tabular data display with sorting and filtering
      </Card>
      <Card title="Chat" icon="comments">
        Responsive Dialog Box
      </Card>
      <Card title="Tabs" icon="folder">
        Tabbed navigation for content organization
      </Card>
      <Card title="Modal" icon="window-maximize">
        Popup dialogs for focused interactions
      </Card>
      <Card title="Image" icon="image">
        Picture display with responsive options
      </Card>
      <Card title="Popover" icon="robot">
       Seamlessly embed any webpage into your site with a simple JavaScript snippet, creating native "in-page" experiences.
      </Card>
        <Card title="Chart" icon="chart-line">
        Data visualization components
      </Card>
    </CardGroup>
  </Accordion>
  

</AccordionGroup>

## Block Event System

The event system is the core communication mechanism between blocks:

<Frame>
  <img src="/images/block-event-system.png" alt="Block Event System" />
</Frame>

### Event Types

<Properties>
  <Property name="Custom Initialization Events" value="Triggered during initialization of a block or page">
    Examples: datatable-block-init, form-block-init
  </Property>

  <Property name="Custom Update Events" value="Triggered to prevent or manage updates to a block or page">
    Examples: datatable-block-update, chat-block-update
  </Property>

    <Property name="Block-Specific Events" value="Triggered by direct user interactions">
    Examples: form-change, block Action (emits an event with payload)
  </Property>
</Properties>

### Event Communication Pattern

<Steps>
  <Step title="Event Definition">
    Blocks define the events they will be emited:
    
    ```yaml
    - slug: Action
      text: Subscribe
      type: event
      value: user-subscribe
      payload:
        user: id
        product: productId
    ```
    
    This creates an event on the system  when the end user interacts with blocks
  </Step>
  
  
  <Step title="Event Subscription">
    Other automations register to receive specific events:
    
    ```yaml
    when:
      events:
        - user-subscribe
      endpoint: false

    ```    
    This tells the automation to listen for the specified event and call the appropriate handler when it occurs.
  </Step>
  
</Steps>

## Advanced Block Features

<AccordionGroup>
  <Accordion title="Block Composition">
    <Frame>
      <img src="/images/block-composition.png" alt="Block Composition" />
    </Frame>
    
    Blocks can be composed from other blocks to create higher-level components:
    
    - **Container Blocks**: Wrap and organize other blocks
    - **Composite Blocks**: Combine multiple blocks into a cohesive component
    - **Layout Blocks**: Control the arrangement of nested blocks
    - **Wrapper Blocks**: Add functionality to existing blocks
    
    Composition enables reuse and maintains separation of concerns.
  </Accordion>
  
  
  <Accordion title="Block Styling">
    <Frame>
      <img src="/images/block-styling.png" alt="Block Styling" />
    </Frame>
    
    Blocks can be styled through multiple approaches:
    
    - **CSS Editor**: Direct CSS customization
    - **Built-in CSS **: Keeping the default CSS
    - **CSS Classes**: Predefined style sets
    
    Consistent styling ensures a cohesive user experience.
  </Accordion>
  
  <Accordion title="Block Conditions">
    <Frame>
      <img src="/images/block-conditions.png" alt="Block Conditions" />
    </Frame>
    
   Blocks can have conditional behavior based on various logical factors:
   
   - Block Display Condition (if): Example: if MyCondition
   - Repeat Block on Array: Example: repeat on MyTable
   - Variable Name for Each Item: Example: MyVariable

    Conditions enable dynamic, responsive interfaces.
  </Accordion>
</AccordionGroup>

## Creating Custom Blocks

For specialized requirements, you can create custom blocks:

<Steps>
  <Step title="Block Definition">
    Start by defining the block's basic information:
    
    ```yaml
    name: Custom Data Table
    slug: custom-data-table
    description: "Interactive table with advanced filtering and sorting"
    yourSpecificSchemaExample1: true
    yourSpecificSchemaExample2: customValue
    ```
    
    This establishes the block's identity within the workspace.
  </Step>
  
  <Step title="Property Schema">
    Define the configurable properties for the block:
    
    ```yaml
    properties:
      data:
        type: array
        description: "Data to display in the table"
      columns:
        type: array
        description: "Column configurations"
      pagination:
        type: object
        properties:
          enabled:
            type: boolean
            default: true
          pageSize:
            type: number
            default: 10
    ```
    
    This creates the contract for how the block can be configured.
  </Step>
  
  <Step title="Event Definition">
    Specify the events the block will emit and handle:
    
    ```yaml
    events:
      emitted:
        - name: row-selected
          description: "Triggered when a row is selected"
          payload:
            type: object
            properties:
              rowId:
                type: string
      subscribed:
        - name: refresh-data
          description: "Trigger the table to refresh its data"
    ```
    
    This establishes the block's communication interfaces.
  </Step>
  
  <Step title="Block Implementation">
    Develop the actual functionality using React:
    
    ```jsx
    import React, { useState, useEffect } from 'react';
    
    const CustomDataTable = ({ 
      properties, 
      emitEvent, 
      addEventListener 
    }) => {
      const { data, columns, pagination } = properties;
      const [selectedRow, setSelectedRow] = useState(null);
      
      // Handle row selection
      const handleRowClick = (row) => {
        setSelectedRow(row);
        emitEvent('row-selected', { rowId: row.id });
      };
      
      // Subscribe to refresh event
      useEffect(() => {
        const removeListener = addEventListener('refresh-data', () => {
          // Refresh data logic
        });
        
        return () => removeListener();
      }, [addEventListener]);
      
      // Render the table UI
      return (
        <div className="custom-table">
          {/* Table implementation */}
        </div>
      );
    };
    
    export default CustomDataTable;
    ```
    
    This implements the block's behavior and rendering.
  </Step>
  
  <Step title="Styling">
    Add custom styles for the block:
    
    ```css
    .custom-table {
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .custom-table-header {
      background-color: #f5f5f5;
      font-weight: bold;
    }
    
    .custom-table-row {
      border-bottom: 1px solid #eee;
      transition: background-color 0.2s;
    }
    
    .custom-table-row:hover {
      background-color: #f9f9f9;
    }
    
    .custom-table-row.selected {
      background-color: #e3f2fd;
    }
    ```
    
    This ensures the block has a consistent, attractive appearance.
  </Step>
  
  <Step title="Testing and Publishing">
    Test the block and make it available in your workspace:
    
    - Create test pages that use the block
    - Verify that properties work as expected
    - Confirm event emission and handling
    - Check appearance across device sizes
    - Import the block into your workspace
    
    Once validated, the block is ready for use in your applications.
  </Step>
</Steps>

## Block Best Practices

<CardGroup cols={2}>
  <Card title="Single Responsibility" icon="circle-check">
    <p>Design blocks to do one thing well:</p>
    <ul>
      <li>Focus on a specific UI function</li>
      <li>Avoid creating overly complex blocks</li>
      <li>Split complex functionality into multiple blocks</li>
      <li>Create specialized blocks for specific use cases</li>
    </ul>
  </Card>
  
  <Card title="Clear Naming" icon="tag">
    <p>Use consistent, descriptive naming:</p>
    <ul>
      <li>Choose clear, descriptive block names</li>
      <li>Use consistent terminology across blocks</li>
      <li>Establish naming conventions for properties and events</li>
      <li>Document the purpose of each block</li>
    </ul>
  </Card>
  
  <Card title="Robust Error Handling" icon="triangle-exclamation">
    <p>Design blocks to handle failures gracefully:</p>
    <ul>
      <li>Validate inputs and handle edge cases</li>
      <li>Provide clear error states and messages</li>
      <li>Implement fallback behavior for missing data</li>
      <li>Log issues for troubleshooting</li>
    </ul>
  </Card>
  
  <Card title="Accessibility" icon="universal-access">
    <p>Ensure blocks work for all users:</p>
    <ul>
      <li>Follow WCAG guidelines for accessibility</li>
      <li>Support keyboard navigation</li>
      <li>Include screen reader compatible markup</li>
      <li>Maintain sufficient color contrast</li>
    </ul>
  </Card>
  
  <Card title="Responsive Design" icon="mobile-screen">
    <p>Optimize blocks for all device sizes:</p>
    <ul>
      <li>Test across different screen sizes</li>
      <li>Implement responsive layouts</li>
      <li>Adjust content for mobile displays</li>
      <li>Use relative units for sizing</li>
    </ul>
  </Card>
  
  <Card title="Performance Optimization" icon="gauge-high">
    <p>Keep blocks efficient and responsive:</p>
    <ul>
      <li>Minimize unnecessary renders</li>
      <li>Optimize heavy operations</li>
      <li>Implement loading states for async operations</li>
      <li>Use lazy loading where appropriate</li>
    </ul>
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Pages"
    icon="file-code"
    href="/products/ai-builder/pages"
  >
    Learn how to combine blocks into complete user interfaces
  </Card>
  <Card
    title="Automations"
    icon="gears"
    href="/products/ai-builder/automations"
  >
    Explore backend logic that interacts with blocks
  </Card>
  <Card
    title="Framework Architecture"
    icon="diagram-project"
    href="/products/ai-builder/framework-architecture"
  >
    Understand the underlying architecture of AI Builder
  </Card>
  <Card
    title="Use Cases"
    icon="lightbulb"
    href="/products/ai-builder/use-cases"
  >
    See examples of blocks in real-world applications
  </Card>
</CardGroup>